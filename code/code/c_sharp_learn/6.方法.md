# 方法
- 在结构或类中声明的**函数**称为方法。
- 对象可以是类的实例，也可以是结构体等
- 方法是指在对象上执行的操作，它可以访问和修改该对象的属性和状态
- 可以没有返回值
```csharp
访问修饰符 可选修饰符 返回类型 方法名称(参数){
 // 方法主体
}
```
#### 访问修饰符
- public：同一程序集中的任何其他代码或引用该程序集的其他程序集都可以访问该类型或成员。 某一类型的公共成员的可访问性水平由该类型本身的可访问性级别控制。
- private：只有同一 class 或 struct 中的代码可以访问该类型或成员。
- protected：只有同一 class 或者从该 class 派生的 class 中的代码可以访问该类型或成员。
- internal：同一程序集中的任何代码都可以访问该类型或成员，但其他程序集中的代码不可以。 换句话说，internal 类型或成员可以从属于同一编译的代码中访问。
- protected internal：该类型或成员可由对其进行声明的程序集或另一程序集中的派生 class 中的任何代码访问。
- private protected：该类型或成员可以通过从 class 派生的类型访问，这些类型在其包含程序集中进行声明
![xiushifu.png](..%2Fimg%2Fxiushifu.png)
#### 可选修饰符
- static
- abstract
- virtual
- override
- new
- sealed
#### 返回值类型
- void
- 基本数据类型
- 自定义类型
### 参数
- 可以值 / 引用传递
- 值传递 类型 变量名
- 引用传递: 使用ref关键字将参数声明为引用类型。这将允许方法更改传递给它的参数的值，并且对传递的变量值的更改将在外部范围中反映出来。
#### 值传递(方法传递的参数)
- C# 类型可以是引用类型 (class)，也可以是值类型 (struct)
- 值传递和引用传递：
  - 值传递 变量的栈数据会完整地复制到目标参数中即实参和形参中的数据相同但存放在内存的不同位置。所以，在目标方法中对形参所做的更改不会对调用者的初始变量产生任何影响。
  - 引用传递  只是将变量的引用复制到目标参数中，实参和形参的引用指向内存中的同一位置。所以，在目标方法中对形参所做的更改会影响调用者的初始变量
- 值类型和引用类型：
  - 值类型的实例在创建时，会为其分配一定的内存空间，该空间用于存储其所有的字段；
  - 引用类型的实例在创建时，只会为其分配一个引用，该引用指向该实例在堆中存储的位置。
- **对比**
  - 当值类型被传递给一个函数时，该函数将实参的值复制到形参中，因此，如果在函数内部修改该值类型的某个字段，它不会影响到调用该函数时的实参。
  - 如果引用类型被传递给一个函数时，该函数将实参的引用复制到形参中，在函数内部对该引用所指向的对象的任何操作都会影响到调用该函数时的实参
- **分析**
  - 值传递 + 值类型: (仅在方法内部生效,不影响原始值)方法只会影响方法内的值,传入参数(值副本),不影响传入的参数原先的值
  - 值传递 + 引用类型:(数据名称: 假设传入参数n,原始数据s) ,对n的修改可以改变s,但在方法内部重新new 的一组参数分配给n时 ,是对n 的一次在堆上的初始化,此时n指向新的内存空间,并且之后对n的任何操作都不会再影响s了
  - 引用传递 + 值类型: 方法内有效,切改变原始数据值
  - 引用传递 + 引用类型: 传入的是引用本身(不是引用副本),区别于值传递时,这里的所有操作都会影响到原始数据
### 值类型&引用类型
- 值类型,变量名替代地址,栈内空间存放具体值(基本数据类型+struct,enum,bool)
- 引用类型,变量名存放在栈,站内存放指向堆的地址, 具体数据指向堆 (类,对象,数组,字符串)
- 值类型: 值类型变量声明后，不管是否已经赋值，编译器为其分配内存(堆)
  - 结构体（数值类型、bool型、用户定义的结构体），枚举，可空类型
- 引用类型 :(栈存引用,new后分配实际存堆) 
  - 当声明一个类时，只在栈中分配一小片内存用于容纳一个地址，而此时并没有为其分配堆上的内存空间。当使用 new 创建一个类的实例时，分配堆上的空间，并把堆上空间的地址保存到栈上分配的小片空间中
  - 数组，用户定义的类、接口、委托，object，字符串
- 适用场合 : 
  - 值类型在内存管理方面具有更好的效率，并且不支持多态，适合用做存储数据的载体；
  - 引用类型支持多态，适合用于定义应用程序的行为
  - 引用类型可以派生出新的类型，而值类型不能，因为所有的值类型都是密封（seal）的
  - 引用类型可以包含null值，值类型不能（特别的:可空类型功能允许将 null 赋给值类型，如   int? a = null;  ）
  - 引用类型变量的赋值只复制对对象的引用，而不复制对象本身。而将一个值类型变量赋给另一个值类型变量时，将复制包含的值
- 对比
  - 都继承自System.Object类,几乎所有的引用类型都直接从System.Object继承，
  - 而值类型则继承其子类，即 直接继承System.ValueType
  - System.ValueType本身是一个类类型，而不是值类型。**其关键在于ValueType重写了Equals()方法**，从而对值类型按照实例的值来比较，而不是引用地址来比较

### 装箱和拆箱
- 是指将值类型转换为引用类型和将引用类型转换为值类型的过程。
- 装箱将值类型封装成一个对象，并在堆上分配其内存空间
- 拆箱则是将装箱后的对象重新转换为原始的值类型。
- 装箱和拆箱会带来一定的性能损失，因此尽量避免频繁使用。

## 方法重载
- 同名方法,不同参数--->方法需要自己独有的逻辑
- 返回值无法区分不同的方法,因此 同参数,同变量名,不同返回值的方法会报错,因为会被认为定义了两个一样的方法
- 同名同参数 可以使用in 关键字重载
```csharp
public static string Area(int value1) //computing area of square
{
    return String.Format("Area of Square is {0}", value1 * value1); 
}
public static double Area(int value1) //computing area of circle
{
    return 3.14 * Math.Pow(value1,2); //using Pow to calculate the power of 2 of value1
}
public static string Area(double value1, double value2) //computing area of rectangle 
{
    return String.Format("Area of Rectangle is {0}", value1 * value2);
}
```
## 参数
### 形参实参
- 在函数或方法的定义中，参数列表中的参数被称为形参，而调用函数或方法时传递给函数或方法的值被称为实参。
- 形参是函数或方法内部使用的标识符，实参是调用代码传递给函数或方法的具体值。
- 在函数或方法执行时，形参将被替换为实参的值，然后被用于计算或运算。
- 实参和形参的数量，类型和顺序必须匹配，否则编译器将提示错误
### params(关键字)
- 在方法声明中的 params 关键字之后不允许有任何其他参数，并且在方法声明中只允许有一个 params 关键字
- 如果 params 参数的声明类型不是一维数组，则会发生编译器错误 CS0225
- 方法可以接受一个可变数量的参数，这些参数被视为同一类型的数组并将其传递到方法中。在方法中，params关键字使代码更灵活，并允许方法接受不同数量的参数。同时，使用params关键字的方法可以在任何位置调用时传递任意数量的参数。
- 可传入:
  - 数组元素类型的参数的逗号分隔列表。
  -  指定类型的参数的数组。
  -  无参数。 如果未发送任何参数，则 params 列表的长度为零
### 参数限制
- 不能将 in、ref 和 out 关键字用于以下几种方法：
  - 异步方法，通过使用 async 修饰符定义。
  - 迭代器方法，包括 yield return 或 yield break 语句。
  - 扩展方法的第一个参数不能有 in 修饰符，除非该参数是结构。
  - 扩展方法的第一个参数，其中该参数是泛型类型（即使该类型被约束为结构。）
  - 都不可以用于引用类型参数,只能用于值类型参数
### in
1. 引用传递：
- 在方法参数中，将对象按引用传递而不是按值传递。使用 `in` 关键字可以确保方法内部只读取对象的值，而不会修改对象本身。例如：

   ```csharp
   void Foo(in int x)
   {
       // Do something with x.
   }

   int y = 10;
   Foo(in y);
   ```

   在上面的例子中，`in` 关键字确保 `Foo` 方法不会修改 `y` 的值。

2. foreach 循环：
- 在 foreach 循环中，将集合元素以只读形式传递给循环体。这意味着不能通过循环变量修改集合元素。例如：

   ```csharp
   List<int> numbers = new List<int> { 1, 2, 3 };

   foreach (in int number in numbers)
   {
       Console.WriteLine(number);
   }
   ```

   在上面的例子中，`in` 关键字确保不能通过 `number` 变量修改 `numbers` 集合中的元素。

3. 数组参数：
- 在方法参数中，将数组按只读方式传递给方法。这确保了方法无法修改数组内容。例如：

   ```csharp
   void PrintArray(in int[] arr)
   {
       foreach (int value in arr)
       {
           Console.WriteLine(value);
       }
   }

   int[] numbers = { 1, 2, 3 };
   PrintArray(in numbers);
   ```

   在上面的例子中，`PrintArray` 方法不能修改 `numbers` 数组中的元素。

- 总之，`in` 关键字用于表示只读访问对象或值类型变量的目的，防止意外地修改它们。


## **递归** 重要
- 尾递归: 如果一个函数中所有递归形式的调用都出现在函数的末尾，我们称这个递归函数是尾递归的
  - 并且该调用的返回值不需要进行其他计算，直接返回即可，没有其他语句需要执行
  - 通过参数传递结果，达到不压栈的目的(可以被编译器优化为 迭代逻辑)
  - 实现尾递归需要将递归转换为循环，将每次递归的参数通过函数参数传递来避免多次调用栈的创建。
```csharp
public static int Factorial(int number) {
    // if number equals 1 or 0 we return 1
    if (number == 1 || number == 0) {
        return 1;
    } else {
        //recursively calling the function if n is other then 1 or 0
        return number * Factorial(number - 1);
    }
}
```