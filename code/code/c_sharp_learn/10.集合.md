# 集合c# 
## List
- List<T> 是一个泛型类(需要实例化, 用 new 关键字), 用于存储一组对象, 他的大小是可变的, 可以动态的增加和删除元素
  C#中的`List<T>`是一种动态数组，可以根据需要自动扩展大小。下面分别介绍`List<T>`的各个API功能和用法：

1. Add

   `Add`方法用于向列表末尾添加一个元素。其定义为：

   ```
   public void Add(T item);
   ```

   例如：

   ```
   List<int> numbers = new List<int>();
   numbers.Add(1);
   numbers.Add(2);
   numbers.Add(3);
   ```

2. Remove

   `Remove`方法用于从列表中删除指定元素。其定义为：

   ```
   public bool Remove(T item);
   ```

   若删除成功，则返回`true`；否则返回`false`。例如：

   ```
   List<int> numbers = new List<int> {1, 2, 3};
   bool removed = numbers.Remove(2); // 返回true
   ```

3. Count

   `Count`属性用于获取列表中元素的数量。例如：

   ```
   List<int> numbers = new List<int> {1, 2, 3};
   int count = numbers.Count; // count = 3
   ```

4. IndexOf

   `IndexOf`方法用于查找指定元素在列表中的位置。其定义为：

   ```
   public int IndexOf(T item);
   ```

   若找到，则返回该元素在列表中的索引；否则返回`-1`。例如：

   ```
   List<int> numbers = new List<int> {1, 2, 3};
   int index = numbers.IndexOf(2); // index = 1
   ```

5. Insert

   `Insert`方法用于在指定位置插入一个元素。其定义为：

   ```
   public void Insert(int index, T item);
   ```

   例如：

   ```
   List<int> numbers = new List<int> {1, 2, 3};
   numbers.Insert(1, 4);
   // numbers = {1, 4, 2, 3}
   ```

6. Sort

   `Sort`方法用于对列表中的元素进行排序。其定义为：

   ```
   public void Sort();
   ```

   对于引用类型的元素，需要实现`IComparable<T>`接口或传入一个实现了`Comparison<T>`委托的比较器。例如：

   ```
   List<string> fruits = new List<string> {"apple", "orange", "banana"};
   fruits.Sort(); // 按字母顺序排序
   // fruits = {"apple", "banana", "orange"}
   ```

7. FindAll

   `FindAll`方法用于查找符合指定条件的所有元素。其定义为：

   ```
   public List<T> FindAll(Predicate<T> match);
   ```

   例如：

   ```
   List<int> numbers = new List<int> {1, 2, 3, 4, 5};
   List<int> evenNumbers = numbers.FindAll(x => x % 2 == 0);
   // evenNumbers = {2, 4}
   ```
- 以上是`List<T>`常用的几个API功能和用法，使用它们可以方便地对列表进行增删改查等操作。同时，还可以使用LINQ语句对列表进行高级操作。

## 哈希表
- 总览
  - Hashtable 
    - 类型：Hashtable 是一种键值对的集合类型，它实现了 IDictionary 接口。
    - 它的键和值都是对象类型，可以通过它实现类似 map 的功能。
  - HashSet<T> 
    - 类型：HashSet<T> 是一种无序、不重复的集合类型。
    - 它实现了 ISet<T> 接口，支持添加、删除、查找等操作，并且具有很好的性能。
  - SortedSet<T> 
    - 类型：SortedSet<T> 是一种有序、不重复的集合类型。
    - 它实现了 ISet<T> 接口，支持添加、删除、查找等操作，并且元素是按照比较器所定义的顺序进行排序的。
  - Dictionary<TKey, TValue> 
    - 类型：Dictionary<TKey, TValue> 是一种键值对的集合类型，
    - 它实现了 IDictionary<TKey, TValue> 接口。可以通过它实现类似 map 的功能。
  - SortedDictionary<TKey, TValue> 
    - 类型：SortedDictionary<TKey, TValue> 是一种有序的键值对集合类型，
    - 它实现了 IDictionary<TKey, TValue> 接口，并且元素是按照键所定义的顺序进行排序的
- 对比
  - Hashtable 和 HashSet
    - 数据结构：Hashtable 使用键值对的形式存储数据，每个元素都由一个键和一个值组成。而 HashSet 只存储键，不存储值。
    - 元素唯一性：Hashtable 中的键必须是唯一的，而值可以重复。而 HashSet 中的键也必须是唯一的，因为它不存储值，每个键本身就代表一个唯一的元素。
    - 实现接口：Hashtable 实现了 IDictionary 接口，它提供了键值对的添加、删除、查找等操作。而 HashSet 实现了 ISet 接口，它提供了元素的添加、删除、查找等操作。
    - 查找性能：Hashtable 在查找元素时需要先计算元素的哈希值，然后再通过哈希值查找元素。这样可以使查找速度非常快，但是在某些情况下可能会出现哈希冲突，需要进行额外的处理。而 HashSet 在查找元素时也需要计算元素的哈希值，但是由于它只存储键，所以不需要进行额外的处理。
    - 内存占用：由于 Hashtable 存储了键值对，所以它的内存占用量比 HashSet 要大。而 HashSet 只存储键，所以占用的内存比较少。

### Hashtable
- System.Collections.Hashtable
```csharp
// 创建一个Hashtable
Hashtable hashtable = new Hashtable();

// 添加元素
hashtable.Add("key1", "value1");
hashtable.Add("key2", "value2");

// 访问元素
Console.WriteLine(hashtable["key1"]);

// 删除元素
hashtable.Remove("key1");

// 获取哈希表中的元素数量
int count = hashtable.Count;

```

### Dictionary<TKey, TValue>
- 这是一个泛型哈希表类型，它可以指定键和值的类型。Dictionary类型通常比Hashtable类型更快和更安全，因为它使用了类型检查和泛型
```csharp
// 创建一个Dictionary
Dictionary<string, int> dict = new Dictionary<string, int>();

// 添加元素
dict.Add("apple", 1);
dict.Add("banana", 2);

// 访问元素
int value = dict["apple"];
Console.WriteLine(value);

// 删除元素
dict.Remove("apple");

// 获取字典中的元素数量
int count = dict.Count;

```

### ConcurrentDictionary<TKey, TValue>
- 一种并发哈希表类型，它支持在多线程环境下添加、删除和查找元素
```csharp
// 创建一个ConcurrentDictionary
ConcurrentDictionary<string, int> concurrentDict = new ConcurrentDictionary<string, int>();

// 添加元素
concurrentDict.TryAdd("apple", 1);
concurrentDict.TryAdd("banana", 2);

// 访问元素
int value;
if (concurrentDict.TryGetValue("apple", out value))
{
    Console.WriteLine(value);
}

// 删除元素
concurrentDict.TryRemove("apple", out value);

// 获取字典中的元素数量
int count = concurrentDict.Count;

```
