## 1.变量

- 一个可以变化的容器，用来存储数据
- 变量都是计算机内存的命名部分，其中包含一些信息
    - 将变量视为一个带有名称的盒子，我们可以在其中“存储”某些东西。
    - 只需要使用一些字母,单词等 当做某个特定数据的 别名(代号),方便指代和操作对应数据


- **声明**: 类型 变量名 = 对应类型初始值;
- **初始化**:  <variable_type> <variable_name> = <value>;

### 1.1变量类型(14个, 8个基本类型, 6个特殊类型, 除去1个object)

- **有符号整数:** sbyte,short,int,long(仅byte多个s)

```csharp
sbyte a = -128; // 8位           -128~127
short b = 32767; // 16位         +-三万多
int c = 2147483647; // 32位      +-21亿多
long d = 9223372036854775807; // 64位  8字  +-九百万兆
```

- **无符号整数:** byte,ushort,uint,ulong,多个u,

```csharp
byte a = 255; // 8位                         0~255
ushort b = 65535; // 16位                    0~6万多
uint c = 4294967295; // 32位                 0~42亿多
ulong d = 18446744073709551615; // 64位      0~18百万兆多
```

- **浮点数:** float,double,decimal
    - float: 加f 是由于小数默认是double类型, 因此加f致命是float类型,避免后续精度问题

```csharp
float a = 3.1415926f; // 32位            7~8位有效数字(从非0数字从左向右数数字个数)
double b = 3.1415926; // 64位            15/17位有效数字
decimal c = 3.1415926m; // 128位         27~28位有效数字 ,一般用于金融计算,基本不用
```

- **特殊类型:** char,bool,string,object

```csharp
char a = 'a'; // 16位                        一个字符
bool b = true; // 8位                        true,false
string c = "hello world"; // 16位            一个字符串
// object d = 123; // 32位                    任意类型            
```

- 不用的类型本质上是占用内存的不同大小, 但是都是用来存储数据的.

### 1.2多个同类型变量声明

- 用逗号隔开

```csharp
int a = 1, b = 2, c = 3;
```

### 1.3变量本质

#### 1.内存空间

- sizeof 查看内存空间(1字节 byte = 8 bit)大小

```csharp
```csharp
int a = 1;
Console.WriteLine(Marshal.SizeOf(a)); // 4 字节
```

- string 是可变长度的, 用来存储字符串, 但是不是基本类型, 是引用类型,因此sizeof不能用来查看string的大小
- c#中的 char 特殊 是 2个字节

#### 2. 变量本质

- 就是二进制01,用最小单位bit存储, 计算机电路只能识别0和1,表示开关状态
- 十进制转二进制
    - 除2取余, 逆序排列
    - 10 = 1010(二进制)
- 二进制转十进制
    - 从右向左, 乘以2的幂次方, 累加
    - 1010 = 10(十进制)
- 二进制转十六进制(A 10 ~~ F 15)
    - 4位二进制转换为1位十六进制
    - 1010 = A

#### 3.命名规范

- 4不
    - 不能以数字开头
    - 不能使用关键字
    - 不能重名
    - 不能使用特殊字符(除了下划线)
- 3要
    - 驼峰命名法,首字母小写,后面每个单词首字母大写( 变量,方法)
    - 帕斯卡命名法,每个单词首字母大写(函数,类,接口)
    - 有意义,大小写是有区别的
    - 有规律

#### 4.变量的作用域

- 作用域: 变量的有效范围
- 作用域分为: 局部变量,全局变量
- 局部变量: 在函数内部声明的变量,只能在函数内部使用
- 全局变量: 在函数外部声明的变量,在整个程序中都可以使用
- 局部变量和全局变量同名时,局部变量会覆盖全局变量

### 1.4常量

- **声明:** const <type> <name> = <value>;
- **初始化:** <type> <name> = <value>;
- 也可以使用直接赋值的方式,但是不推荐
- 特点
    - 常量的值不能改变
    - 常量必须初始化

### 1.5转义字符

- \ + 需要转义的字符
- 具体需要使用时,查文档

### 1.6变量类型转换

- 小范围到大范围会隐式转换(自动转换)
- 大范围到小范围显示转换会截断, 可能造成误差(需要显示转换)

#### 1. (type)括号

- 主要数值类型,低精度强转为高精度
- 不支持 bool 和 string 转换 为整形/浮点数

```csharp
int i = 1;
short s = (short)i;
```

#### 2. Parse
- 可以把字符串 string 转换为 对应类型
- 报错
    - 字符串要求必须有对应类型的字符,比如中文仅仅是字符无法转换为整数...等等
    - 必须在对应类型(需要转换的目标类型)的范围内
    - PS: 浮点数会被截断,不会报错

```csharp
int  a = int.Parse("123"); // 转换为整数
short b = short.Parse("123"); // 转换为短整数
int c = int.Parse("123.123"); // 报错,str中是小数,但目标类型是整数
short d = int.Parse("12345678"); // 报错,超出了short的范围
bool e = bool.Parse("true"); // 转换为布尔值
char f = char.Parse("a"); // 转换为字符
float g = float.Parse("123.123"); // 转换为浮点数
```

#### 3. Convert

- Convert.To目标类型(常量/ 变量)
- 更准确的各个类型之间的转换
- 填写变量/常量必须正确

```csharp
int a = Convert.ToInt32("123"); // 转换为整数
a = Convert.ToInt32(1.235654f); //会四舍五入
a = Convert.ToInt32('A');  // 输出65 
// bool true1, false0 

sbyte b = Convert.ToSByte("123"); // 转换为短整数
short c = Convert.ToInt16("123"); // 转换为短整数
int d = Convert.ToInt32("123"); // 转换为整数
long d = Convert.ToInt64("123"); // 转换为长整数
// 无符号多个u
uint d = Convert.ToUInt32("123"); // 转换为无符号整数

bool e = Convert.ToBoolean("true"); // 转换为布尔值
char f = Convert.ToChar("a"); // 转换为字符
string j = Convert.ToString("123.123"); // 转换为字符串

float g = Convert.ToSingle("123.123"); // 转换为单精度浮点数
double h = Convert.ToDouble("123.123"); // 转换为双精度浮点数

```

#### 4. 其他类型转换为string

- **拼接打印**,当进行字符串拼接时,会自动调用ToString()方法
- 变量.ToString()

```csharp
string a = 1.ToString();
string b = 1.123.ToString();
string c = true.ToString();
string d = 'a'.ToString();

int a = 10;
string e = a.ToString();
// 拼接打印 , 输出 : a = 110True
Console.WriteLine("a = " + 1+ a + true);
```

## 2.输入输出
- Console.ReadLine() // 讲输入内容,存入一个string类型变量中

## 3.异常捕获
### 语法
- try catch finally 基本结构不用分号, 里面的代码用分号
```csharp
try{
    // 可能出现异常的代码
    // try中的代码,如果出现异常,会跳过try中的代码,执行catch中的代码
    // 不会直接报错
}catch (Exception e){
    // 异常处理
    // e是一个变量,可以打印异常信息, 可以选择不写  (Exception e)
}finally{ 
    // 可选部分
    // 无论是否出现异常,都会执行的代码
}
```

## 4.运算符
- 统一使用小括号 () 包裹,方便阅读(优先级限定)
### 1.算术运算符
- + - * / % 加 减 乘 除 取余
- 除法运算,如果两个数都是整数,结果也是整数,如果有一个是小数,结果就是小数
### 2.关系(条件)运算符(优先级低,一般双侧数都算好后才比较)
- == != > < >= <=  等于 不等于 大于 小于 大于等于 小于等于
- 返回值是bool类型
- 比较值的大小关系,不是地址
```csharp
int a = 10;
int b = 10;
Console.WriteLine(a == b); // true
```
- 不能进行范围比较,比如 a > b > c, 若需要比较多个值,可以使用逻辑运算符
- **不同类型之间比较**
  - 不同数值类型之间可以比较
  - 特殊类型 char string bool 只能和自己类型比较,使用 == !=
  - **特别:** char和int可以比较,比较的是ASCII码
```csharp
char a = 'a';
char b = 'b';
Console.WriteLine(a == b); // false
```

### 3.逻辑运算符
- && || ! 与 或 非
- 与: 同true,结果为true,否则为false
- 或: 同false,结果为false,否则为true 
- 非: 取反
- 逻辑运算符,只有两个bool类型的值才能参与运算
- 混合使用逻辑运算符,优先级: ! > && > ||
- 短路运算: 逻辑运算符,如果前面的结果已经可以确定最终结果,后面的代码不会执行
  - || 有一个为true,结果为true,后面的代码不会执行
  - && 有一个为false,结果为false,后面的代码不会执行


### 4.赋值运算符(先看右侧,再赋值给左侧)
- = += -= *= /= %=
- a +=  b  和  a =  = a + b 等价
- 不能连续赋值,比如 a = b = c = 10; 会报错
- ps: 除法转整数 向0取整
### 5.其他运算符
- ++ -- 自增 自减
```csharp
int a = 10;
int b = a++; // b = 10, a = 11 , 先赋值,再自增
int c = ++a; // c = 12, a = 12 , 先自增,再赋值
```
### 6.字符串拼接
- 6.1 两个运算符 + , += ,都是字符串拼接
```csharp
string a = "123";
string b = "456";
string c = a + b; // c = 123456 不是计算,是拼接
b += a; // b = 456123

// 根据第一个字符,判断是数字还是字符串 得出计算or拼接
string d += "123"+4 +5; // d = 12345 , "123"+4+5 = 12345
string e += 1+2+ 3; // e = 6 , 1+2+3 = 6
```
- 6.2字符串拼接,可以使用string.Format()方法
  - string.Format("{0}",变量/常量) 0~n是占位符,可以有多个,从0开始
  - 拼接后要赋值给一个字符串变量才可以使用
```csharp
string a = "123";
string b = "456";
string c = string.Format("{0}{1}", a, b); // c = 123456
```
- 6.3字符串拼接,可以使用$符号
```csharp
string a = "123";
string b = "456";
string c = $"{a}{b}"; // c = 123456
```
- 6.4控制台输出,可以使用Console.WriteLine()方法
  - Console.WriteLine()方法,可以直接输出变量/常量,不需要拼接
  - 多余的参数会被忽略,不会报错
  - 少填写的参数,会报错
```csharp
string a = "123";
string b = "456";
// 两种方式都可以
Console.WriteLine("测试一下{0}{1}",a , b); //  测试一下123456
console.WriteLine(a + b); // 123456
```
### 7.位运算符
- 讲两个数值,转换成二进制,然后进行运算(数值类型)
- & | ^ ~ << >> 与 或 异或 取反 左移 右移
- & 位与: 二进制对应位, 有0就是0,全是1才是1
- | 位或: 二进制对应位, 有1就是1,全是0才是0
- ^ 位异或: 二进制对应位, 相同为0,不同为1
- ! 位取反: 0变1,1变0
- 左移<<: 二进制,右侧补0,左侧移出(移动一位,相当于乘以2)
- 右移>>: 二进制,左侧补0,右侧移出(移动一位,相当于除以2)

### 8.三元运算符
- **语法:** 变量 =  条件(bool表达式) ? 表达式1(真) : 表达式2(假)
- 作用: 根据条件,返回表达式1或表达式2的值
- 优先级: 低于赋值运算符
- 逻辑运算符,可以使用三元运算符代替
```csharp
int a = 10;
int b = 20;
int c = a > b ? a : b; // c = 20
```

## 条件分支
### 1. if else
- 语法: 不需要写分号,内部具体代码写分号
```csharp
if(bool条件表达式){
    // 条件为真,执行的代码
}else{
    // 条件为假,执行的代码
}
```
### 2. switch case
- 语法: case 后面的值,必须是整数/字符/字符串(常量)
- 不可以是范围,不可以是条件/逻辑运算符
- **搭配 枚举 使用**
- 变量要求已经初始化 / 已经赋值
```csharp
switch(变量/常量){
    case 常量1:
        // 代码
        break;
    case 常量2:
        // 代码
        break;
    default:
        // 代码
        break;
}

// 优化写法使用lambda表达式
int a = 1;
int b = a switch {
    1 => 2,
    123 => 456,
    _ => 789
};
```
### 3. 贯穿switch,不写break
- 语法: 在case后面加上关键字 **goto case 常量;** // 不推荐goto
  - 也可以直接把 case放一起写
- 作用: 跳转到指定的case,继续执行
- 注意: 不能跳转到default,也不能跳转到break
```csharp
// 写法1
switch(变量/常量){
    case 常量1:
        // 代码
        goto case 常量2;
    case 常量2:
        // 代码
        break;
    default:
        // 代码
        break;
}

// 写法2
switch(变量/常量){
// case1 满足,即使case2不满足,也会执行case2的代码,直到break;
    case 常量1:
    case 常量2:
        // 代码
        break;
    default:
        // 代码
        break;
}
```

## 循环
### 1. while
- 语法: 不需要写分号,内部具体代码写分号
```csharp
while(bool条件表达式){
    // 条件为真,执行的代码
}
```
### 2. do while
- 语法: 不需要写分号,内部具体代码写分号
```csharp
do{
    // 条件为真,执行的代码
}while(bool条件表达式);
```
### 3. for
- 语法: 不需要写分号,内部具体代码写分号
```csharp
for(初始化表达式;条件表达式;迭代表达式){
    // 条件为真,执行的代码
}
```
### 4. foreach
- 语法: 不需要写分号,内部具体代码写分号
```csharp
foreach(类型 变量 in 数组/集合){
    // 条件为真,执行的代码
}
```
### 5. break
- 作用: 跳出当前循环
- 注意: 只能跳出当前循环,不能跳出外层循环
- 适用: 一般用于跳出某些不需要执行的代码
```csharp
for (int j = 0; j < 3; j++) {
    for(int i = 0; i < 5; i++){
        if(i == 4){
            break ;
        }
        Console.WriteLine(i);
    }
    Console.WriteLine("j = " + j);
}
```
### 6. continue
- 作用: 跳过当前循环,继续执行下一次循环
- 注意: 只能跳出当前循环,不能跳出外层循环
- 适用: 一般用于跳过某些不需要执行的代码
```csharp
for(int i = 0; i < 10; i++){
    if(i == 5){
        continue;
    }
    Console.WriteLine(i);
}
```
### 7. goto
- 作用: 跳转到指定的位置,继续执行
- 注意: 不能跳转到break,也不能跳转到switch的case
- 适用: 一般用于跳过某些不需要执行的代码
```csharp
for(int i = 0; i < 10; i++){
    if(i == 5){
        goto label;
    }
    Console.WriteLine(i);
}
label:
Console.WriteLine("跳转到这里");
```


## PS: 
### 1.折叠代码
- 使编程逻辑更加清晰，方便阅读，配对使用，可以折叠代码(方便阅读)
- 仅编辑器给的预处理指令，不会影响编译结果
- 发布或执行时，会自动删除

```csharp
# region 折叠代码
// 代码
# endregion
```
### 2. 代码提示注释
- tip1: 
```csharp
/// <summary>
/// 代码提示注释 具体内容
/// </summary>
/// <param name="参数名">参数说明</param>
```


