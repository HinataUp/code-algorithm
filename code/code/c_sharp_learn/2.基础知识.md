## 1.复杂数据类型

### 1.1 枚举

#### 概念

- 枚举是一组有名字的整型常量集合
- 不能定义在方法中(函数语句块中),
    - 一般声明在namespace中
    - 也可以放在类中,struct中
- **声明枚举:**
    - 创建一个自定义枚举类型,并且给每个枚举成员赋值

```csharp
enum e_Name{
    枚举成员1, // 默认值为0,后面的枚举成员值依次加1
    枚举成员2,
    枚举成员3,
    ...
}
```

- **声明枚举变量:**
    - 搭配分支语句使用,写在方法内部
    - 避免通过数字来判断,而是通过枚举名来判断

```csharp
// 枚举名 变量名;
e_Name new_name;
// 比较枚举类型
e_Name new_name = e_Name.Main;
if(new_name == e_Name.Main){
    Console.WriteLine("new_name == e_Name.Main");
}else if( new_name == e_Name.Other)){
    Console.WriteLine("new_name != e_Name.Main");
}
// 搭配switch语句使用
switch(new_name){
    case e_Name.Main:
        Console.WriteLine("new_name == e_Name.Main");
        break;
        // 贯穿
    case e_Name.Other:
    default:
        Console.WriteLine("new_name == e_Name.Other");
        break;
}
```

#### 类型转换(用的少)

- 和int类型可以相互转换
- 和string类型相互转换

```csharp
// int类型转换为枚举类型
e_Name new_name = (e_Name)1;
// 枚举类型转换为int类型
int num = (int)e_Name.Main;
// 枚举类型转换为string类型
string str = e_Name.Main.ToString();
// string类型转换为枚举类型 Parse(目标枚举类型,待转换的字符串)
e_Name new_name = (e_Name)Enum.Parse(typeof(e_Name), "Main");
```

### 1.2 数组

#### 一维数组

- 一种数据结构, 类型相同,再同一个名称(数组名)下的数据集合
- 在内存中是连续的,通过下标访问

```csharp
// 1. 静态数组 编译时再内存中分配,内存在 堆栈 stack上分配一本数组名,并未分配内存
type[] arrayName ;
// 2. 动态定义 分配在堆中 heap,已经分配了内存,需要手动释放,
type[] arrayName = new type[size]; 
// 3. 声明并初始化, new type[size]可以省略 或单独size 都可以省略
// size定义容量,后面的值个数不能超过size且决定了当前实际的数组大小
type[] arrayName = new type[size] {value1, value2, ..., valueN};
```

##### 初始化(数组必须初始化才可以使用)

1. 静态-- stack中,大小固定离开作用域后自动释放

```csharp
// 定义
int []arr = {1,2,3};
// 声明并初始化
int []arr2;
arr2 = {2,3,4};
```

2. 动态-- new出来的 ,在heap中,运行时分配大小(动态扩展),需要手动释放

```csharp
 int[] arr = new int[3] {7,9,4};
 // 也可以不指定大小
 int[] arr = new int[] { 24, 2, 13, 47, 45 };
```

##### 遍历 & 修改

```csharp
// 循环 访问
// 通过 arr[index]
// arr[index] = 1 ; 进行修改值
```

#### 多维数组(矩阵,一组数的 一定规律排列)

- 没行的 列数都是相同的,比如5行3列,对应的数组应该是一个矩形

```csharp
// 二维数组, 4组,每组内3个元素
int [,] arr = new int[4,3];
// 三维数组
int [,,] arr = new int[2,3,4];
// 可以声明时初始化
int[,] arr = new int[4, 2] { {1, 1}, {2, 2}, {3, 3}, {4, 4} };
// 通过下标访问
arr[2,1];
```

#### 交错数组(数组的数组)--推荐:使用起来更快、更安全。

- 类似于多维数组,但是每行列数可以不同,定义时无强制制定要求

```csharp
int[][] arr = new int[5][];
int[][] a = new int[8][];
for (int i = 0; i < a.Length; i++){
    a[i] = new int[10];
}
// get set 值和 多维数组一样
```

#### 操作(注意加不加括号)

- 调用: 方法加括号,属性不加括号
- GetLength() 获取数组的维数 0行 1列 2层(三维)
- GetUpperBound() 获取数组的最大下标
- Length 获取数组的长度(元素个数) (一维中 与GetLength()一样)
- Rank 获取数组的维数
- 一维数组长度 Length = GetLength(0)
- 二维数组长度 Length = GetLength(0) * GetLength(1)
- 三维数组长度 Length = GetLength(0) * GetLength(1) * GetLength(2)

#### 对比 多维 & 交错

- 多维数组可以看做是多个一维数组按照一定规律排列组合起来的结果，而交错数组则是由多个不同长度的一维数组组成的数组。
- 多维数组中每个元素都是一个数组，可以通过指定坐标来访问特定的数组元素。相比之下，交错数组中的每个元素是一个单独的值，而且不同行的长度也可以不一样，需要通过嵌套循环的方式逐个访问。
- 因此，在一些特定的场景下，交错数组的性能表现可能会更好

### 1.3 结构体(一般用的少,推荐用class)
#### 1.自定义变量类型,类似枚举需要自己定义
  - 数据和函数的集合
  - 可以声明各种变量和方法
  - 用于表现存在关系的数据结合
#### 2.语法 :struct
```csharp
// 一般写在namespace下
// 命名规范: pascal命名法 
struct structName{
    // 成员变量
    // 构造函数,可选,默认无参数,可以写带参构造法
    // 成员方法(写一些该函数可以拥有的方法)
}
```
#### 3.使用
- 构造函数
  - 没有返回值
  - 函数名必须和结构体相同
  - 必须有参数
  - 如果声明了构造函数,则必须手动初始化所有成员变量
  - 使用this.成员变量名 = 参数名;进行初始化 避免混淆
```csharp
// 1. 声明
structName structName{
    // 成员变量,默认私有
    string name;
    int age;
};
// 2. 初始化
structName structName = new structName();
// 3. 赋值
structName.name = "name";
structName.age = 18;
// 4. 赋值
structName structName = new structName("name",18);
```
#### 4.注意
- 结构体是值类型,变量名替代地址,栈内空间存放具体值(基本数据类型+struct,enum,bool)
- 结构体不能继承,不能被继承
- 结构体不能声明为抽象的,不能声明为虚方法

## 2.值类型和引用类型(重点)

- **值类型:** 四种基本数据类型,枚举,结构体
- **引用类型:** 数组,字符串,类,接口,委托

### 值类型&引用类型

- 值类型,变量名替代地址,栈内空间存放具体值(基本数据类型+struct,enum,bool)
- 引用类型,变量名存放在栈,站内存放指向堆的地址, 具体数据指向堆 (类,对象,数组,字符串)
- 值类型: 值类型变量声明后，不管是否已经赋值，编译器为其分配内存(栈)
    - 结构体（数值类型、bool型、用户定义的结构体），枚举，可空类型
- 引用类型 :(栈存引用,new后分配实际存堆)
    - 当声明一个类时，只在栈中分配一小片内存用于容纳一个地址，而此时并没有为其分配堆上的内存空间。当使用 new
      创建一个类的实例时，分配堆上的空间，并把堆上空间的地址保存到栈上分配的小片空间中
    - 数组，用户定义的类、接口、委托，object，字符串
- 适用场合 :
    - 值类型在内存管理方面具有更好的效率，并且不支持多态，适合用做存储数据的载体；
    - 引用类型支持多态，适合用于定义应用程序的行为
    - 引用类型可以派生出新的类型，而值类型不能，因为所有的值类型都是密封（seal）的
    - 引用类型可以包含null值，值类型不能（特别的:可空类型功能允许将 null 赋给值类型，如 int? a = null; ）
    - 引用类型变量的赋值只复制对对象的引用，而不复制对象本身。而将一个值类型变量赋给另一个值类型变量时，将复制包含的值
- 对比
    - 都继承自System.Object类,几乎所有的引用类型都直接从System.Object继承，
    - 而值类型则继承其子类，即 直接继承System.ValueType
    - System.ValueType本身是一个类类型，而不是值类型。**其关键在于ValueType重写了Equals()方法**，从而对值类型按照实例的值来比较，而不是引用地址来比较
    - 由于值类型的实例是直接存储在栈中的，所以在创建值类型的实例时，不需要使用new关键字，而是直接使用赋值语句即可
    - 值类型的实例在创建时，会在栈中分配内存空间，而引用类型的实例在创建时，只会在栈中分配内存空间，而不会在堆中分配内存空间
- 使用区别:
    - 值类型 拷贝了值, 对于其中一个变量的修改,不会影响另一个变量
    - 引用类型 拷贝了引用地址, 对于其中一个变量的修改,会影响另一个变量,因为本质上修改了内存地址存的对应的值

### 特殊引用类型string

- "他变我不变"
- 具备值类型的特性,但是又是引用类型
- str2 表面上是str赋值,实际上是重新new了一个对象,并且把str的值赋值给了str2
    - 因此修改str2的值,不会影响str的值

```csharp
string str = "hello";
string str2 = str;
str2 = "world";
Console.WriteLine(str); // hello
```

- 缺点:
    - 尽管string作为可变字符串使用方便,但是频繁的修改字符串,会产生大量的垃圾,影响性能
- 优化: 为了解决这个问题,微软推出了StringBuilder类,用于频繁修改字符串的场景





## PS: 

#### 堆栈理解,系统中堆和栈的区别

- 堆和栈都是用来存储数据的内存区域，
- 使用方式和特点有所不同
    - 栈是一种内存区域，它按照“先进后出”的原则存储函数的调用过程、局部变量等临时数据；
    - 堆则是一种动态内存分配方式，用于存储程序运行期间动态分配的数据，
- 例如创建对象时使用的内存空间。
    - 堆和栈的大小都是有限制的，但是堆的大小可以动态增长和释放
- 另外，堆和栈的内存管理方式也有所不同：
    - 堆的内存由程序员手动分配和释放，
    - 栈则由程序自动管理。因此，在使用堆和栈时需要注意内存的分配、使用和释放，以避免内存泄露和其他问题的发生。

#### var使用

- 有时候不想制定类型,可以使用var进行类型推断,
- 该方法还挺有用!