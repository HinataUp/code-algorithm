# 类&结构体
## 定义
```csharp
[private/public/protected/internal] class <Desired Class Name> [:[Inherited class][,][[Interface Name 1],[Interface Name 2],...]{
 //Your code
}
```
### 构造函数
- 当定义的类灭有构造函数时，编译器会自动创建一个无参的构造函数。
- 带参数的构造函数可以用来初始化类的成员变量。(可以使用new 实现)
### get set(针对的是属性,切记一个类中定义包含get set 的是属性property 而不是方法method)
- get set 是一对方法,用于获取和设置成员变量的值
- get set 方法的名称一般为 get + 成员变量名称, set + 成员变量名称
- get set 方法的访问修饰符一般与成员变量的访问修饰符相同,返回值同理
- 但是,如果成员变量是私有的,那么get方法的返回值可以是成员变量的类型的父类
- get set 方法的参数一般为0个,如果有参数,那么参数的类型一般为成员变量的类型的父类
- get set属性访问器中不能有任何逻辑:
  - 属性的get和set方法中不应该包含任何复杂的逻辑，它们应该只是简单地获取或设置属性的值。
  - 这是为了确保属性的快速和一致的访问，避免不必要的副作用和错误。
```csharp
public bool IsValid {
        get {
            return _isValid; // get returns the field you specify when this property is assigned
        }
        set {
            //The C# keyword value contains the value assigned to the property. 
            _isValid = value; // set assigns the value assigned to the property of the field you specify
        }
 }
 // 简写
public bool IsValid { get; set; }
// 设置默认值
public class Name{
 public string First { get; set; } = "James";
 public string Last { get; set; } = "Smith";
}
```
### 析构函数
- 析构函数是在对象被销毁时调用的函数。
- 析构函数的名称与类名相同，但是在前面加上了一个波浪号（~）。
- 析构函数不能被继承，也不能被重载。
- 析构函数不能带有任何访问修饰符。
- 析构函数不能有参数。
- 析构函数不能被调用，它是在对象被销毁时自动调用的。
- 析构函数不能被显式调用，也不能被继承。
- 析构函数不能被重载。


### static 类
- 此值不会因对象而异，而是在整个类上发生变化。
- 不能被实例化，因此不能创建对象。静态类经常用于为应用程序提供实用程序方法。常见的静态方法包括字符串操作、数值转换等
- 静态类被标记为 sealed，即已被密封的，因此它不能派生自其他类。静态类中的所有成员都必须是静态的。
- 
### sealed 类
- sealed 类不能被继承，因此不能派生自其他类。sealed 类经常用于创建不可变的类，即一旦创建了对象，就不能再更改对象的状态。
- 如果将一个类同时定义为 abstract 和 sealed，则这是一种矛盾的修饰符组合，因为 abstract 表示该类必须被继承，而 sealed 表示该类不能被继承。因此，这种修饰符组合是不合法的，编译器会报错



### 接口interface和抽象类abstract
- 接口和抽象类的区别在于，接口只定义了方法的签名而没有实现，而抽象类可以定义方法的实现。
- 类可以实现多个接口，但只能继承一个抽象类。
- 接口适用于不相关的类之间的通信，而抽象类适用于相关的类之间的联系。
- 此外，接口中的所有成员都是公共的，而抽象类可以有公共、受保护和私有成员

## 结构体
- 结构体是值类型，类是引用类型。
- 不能继承其他结构体或类，但可以实现接口。
- 不能声明无参数的构造函数（因为结构体不能被实例化）。
- 结构体不能继承其他结构体或类，也不能作为基类使用。使用结构体的好处是它们比类更有效率，因为它们被分配在堆栈中而不是堆中。
- 使用结构体的另一个好处是，它们可以不使用 new 运算符就可以被实例化。(可以使用new 实现,不强制)
  - 它是小型数据结构
  - 它不需要继承或多态性
  - 它的生命周期很短
  - 它会频繁地被创建和销毁
- **禁用:**
  - 当结构体需要频繁地被赋值或传递到方法中时。
  - 当结构体需要在多线程环境下使用时