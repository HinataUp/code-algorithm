# 面相对象
## 1.理论(三大特性)
### 1.1对比
- 面向过程
  - 一过程为中心,把数据和功能封装到一起
  - 分析解决问题的步骤,把每个步骤分解成一个个小的函数
  - 使用时候,按照步骤调用函数
  - 优点: 简单,容易理解
- 面向对象
  - 一对象为中心,把数据和功能封装到一起
  - 分析解决问题的对象,把每个对象分解成一个个小的类(万物皆对象)
- 什么是类(**引用类型**)
  - 具有相同特征,相同行为,一类实物的抽象程序表达
  - 类是对象的模板,对象是类的实例
  - 关键词 class
  - 声明位置: namespace下 或者class内部(内部类)
  - 实例化: 类名 对象名 = new 类名();
  - 包含内容: 成员变量,构造函数,成员方法,构造函数,析构函数,属性,索引器,事件,运算符重载,静态成员
  - 访问修饰符: public,private,protected,internal,protected internal
```csharp
// 1. 声明,并未实例化
class ClassName{
    // 成员变量,默认私有
    string name;
    int age;
    // 构造函数,可选,默认无参数,可以写带参构造法,可以重载
    public ClassName(){
        // 初始化
    }
    // 成员方法(写一些该函数可以拥有的方法),默认私有
    public void Method(){
        // 方法体
    }
}
// 2. 实例化
// 只要是new出来的对象,都是在堆上分配各自的内存, 互相之间数据不共享
ClassName obj = new ClassName();
// 空实例化 ,仅在栈上声明,不在堆上分配内存
ClassName obj = null; // ClassName obj;等价
// 3. 调用
obj.Method();
```
### 1.2说明
#### PS 可以声明和类同名的变量,甚至同类名相同的数组
- 但是不能在类内对它实例化,类外可以使用依情况调用
#### 成员变量
  - 声明在类中,方法外,描述对象特征,可以是任意变量类型 ,数量不限,是否赋值根据需求
#### 访问修饰符
  - public: 公有,任何地方都可以访问
  - private: 私有,只能在类内部访问
  - protected: 受保护,只能在类内部和子类中访问
  - internal: 内部,只能在当前程序集中访问
  - protected internal: 受保护的内部,只能在当前程序集中或者子类中访问
#### 未初始化的编译器默认值
  - 数值类型: 0
  - bool类型: false
  - 引用类型: null
  - 查看方法: `Console.WriteLine(default(int));` // char是空 因此什么都看不到
#### 成员方法--函数
- 声明在类语句中 ,描述对象行为 ,规则和函数声明一样
- 受访问修饰符限制 ,返回值参数不限制 ,方法数量不限制,且可以重载, 
- 不要用static修饰, 必须实例化处对象,在通过对象类使用,相当于对象执行了某个方法
```csharp
// 人类包含朋友数组,朋友数量,添加朋友,删除朋友方法,朋友数组
public class Person{
    // 朋友数组
    private string[] friends = new string[4];
    // 朋友数量
    private int friendCount = 0;
    // 添加朋友方法 包含扩容逻辑
    public void AddFriend(string name){
        // 扩容逻辑,2倍扩容
        if(friends.Length == friendCount){
            string[] newFriends = new string[friends.Length * 2];
            for(int i = 0; i < friends.Length; i++){
                newFriends[i] = friends[i];
            }
            friends = newFriends;
        }
        // 添加朋友
        friends[friendCount] = name;
        friendCount++;
    }
    // 删除朋友方法,包含缩容逻辑
    public void RemoveFriend(string name){
        // 查找朋友
        int index = -1;
        for(int i = 0; i < friendCount; i++){
            if(friends[i] == name){
                index = i;
                break;
            }
        }
        // 删除朋友
        if(index != -1){
            for(int i = index; i < friendCount - 1; i++){
                friends[i] = friends[i + 1];
            }
            friendCount--;
        }
        // 缩容逻辑,1/2缩容
        if(friends.Length / 2 == friendCount){
            string[] newFriends = new string[friends.Length / 2];
            for(int i = 0; i < friendCount; i++){
                newFriends[i] = friends[i];
            }
            friends = newFriends;
        }
    }
}

```
#### 构造函数
- 用于初始化对象,在实例化对象时自动调用,不需要手动调用,不写默认无参构造函数
- 写法1: (一般public)修饰符 类名(参数列表){} ,
  - 参数列表可以为空,可以有参数,可以重载,没有返回值
  - this 表示当前对象,可以用来区分成员变量和局部变量(尤其是外部传入的参数和成员变量同名时)
  - **一旦写了有参构造函数,默认无参构造函数就没有了,需要手动写**
- 写法2: (一般public)修饰符 构造函数名(参数列表):this(参数列表){} ,
  - 用于调用当前类中的其他构造函数,必须写在构造函数的第一行,
  - 参数列表可以用变量 甚至写常量,只要类型是存在的构造函数带的参数类型即可
  - 一般用于构造函数重载,避免重复代码, this后的参数列表可以不带
  - **用于减少复用代码量**
```csharp
// 1. 无参构造函数
public Person(){
    // 初始化
}
// 2. 有参构造函数
public Person(string name, int age){
    // 初始化
    this.name = name;
    this.age = age;
}
// 3. 重载构造函数, this 复用了无参构造函数, 
// 先调用this的构造函数,再执行当前构造函数,此处
public Person(string name, int age):this(){

}
```
#### 析构函数
- unity中几乎不会调用,用于释放资源,在对象被销毁时自动调用,不需要手动调用
- c#有GC机制,除非进行一些特殊操作,否则不会调用
- **语法:** ~类名(){}

### 垃圾回收机制 gc

### 1.3封装
### 1.4继承
### 1.5多态

## 2.七大原则
### 开闭原则
### 依赖倒置原则
### 里氏替换原则
### 单一职责原则
### 接口隔离原则
### 合成复用原则
### 迪米特法则
